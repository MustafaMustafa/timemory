//  MIT License
//
//  Copyright (c) 2019, The Regents of the University of California,
//  through Lawrence Berkeley National Laboratory (subject to receipt of any
//  required approvals from the U.S. Dept. of Energy).  All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.

#include "timemory/component_operations.hpp"
#include "timemory/components.hpp"
#include "timemory/environment.hpp"
#include "timemory/manager.hpp"

//======================================================================================//

template <typename ObjectType>
void
tim::graph_storage<ObjectType>::print()
{
    if(!singleton_t::is_master(this))
    {
        singleton_t::master_instance()->merge(this);
    }
    else if(env::auto_output())
    {
        merge();

        auto _manager = tim::manager::master_instance();

        typedef decltype(graph().begin()) predicate_type;
        auto _reduce   = [](predicate_type lhs, predicate_type rhs) { *lhs += *rhs; };
        auto _this_beg = graph().begin();
        auto _this_end = graph().end();
        graph().reduce(_this_beg, _this_end, _this_beg, _this_end, _reduce);

        m_data.current() = m_data.head();
        int64_t _width   = ObjectType::get_width();
        for(const auto& itr : m_data.graph())
        {
            int64_t _len = itr.prefix().length();
            _width       = std::max(_len, _width);
        }

        std::stringstream _oss;
        std::stringstream _mss;
        for(const auto& itr : m_data.graph())
        {
            auto _id     = itr.id();
            auto _obj    = itr.obj();
            auto _prefix = itr.prefix();  // + std::to_string(itr.id());
            auto _laps   = _obj.laps;
            component::print<ObjectType>(_obj, _oss, _prefix, _laps, _width, true);
            component::print<ObjectType>(_obj, _mss, false);
            if(_manager)
            {
                if(_mss.str().length() > 0)
                    _manager->insert(_id, _prefix, _mss.str());
            }
        }

        if(env::file_output() && _oss.str().length() > 0)
        {
            auto label = ObjectType::label();
            //--------------------------------------------------------------------------//
            // output to text
            //
            if(env::text_output())
            {
                auto          fname = tim::env::compose_output_filename(label, ".txt");
                std::ofstream ofs(fname.c_str());
                if(ofs)
                {
                    auto_lock_t l(type_mutex<std::ofstream>());
                    printf("[graph_storage<%s>]> Outputting '%s'...\n",
                           ObjectType::label().c_str(), fname.c_str());
                    ofs << _oss.str();
                    ofs.close();
                }
                else
                {
                    auto_lock_t l(type_mutex<decltype(std::cout)>());
                    fprintf(stderr,
                            "[graph_storage<%s>::%s @ %i]> Error opening '%s'...\n",
                            ObjectType::label().c_str(), __FUNCTION__, __LINE__,
                            fname.c_str());
                    std::cout << _oss.str();
                }
            }

            //--------------------------------------------------------------------------//
            // output to json
            //
            if(env::json_output())
            {
                auto_lock_t l(type_mutex<std::ofstream>());
                auto        jname = tim::env::compose_output_filename(label, ".json");
                printf("[graph_storage<%s>]> Outputting '%s'...\n",
                       ObjectType::label().c_str(), jname.c_str());
                serialize_storage(jname, ObjectType::label(), *this);
            }
        }

        if(env::cout_output() && _oss.str().length() > 0)
        {
            auto_lock_t l(type_mutex<decltype(std::cout)>());
            std::cout << _oss.str() << std::endl;
        }
    }
}

//======================================================================================//
